<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Concurrent Image Processing in Go: Pixelization</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Concurrent Image Processing in Go: Pixelization</h1>
</header>
<section data-field="subtitle" class="p-summary">
Go is very neat and its support for concurrency is powerful. So you should not think twice about your language choice when your task is to…
</section>
<section data-field="body" class="e-content">
<section name="fdd7" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9748" id="9748" class="graf graf--h3 graf--leading graf--title">Concurrent Image Processing in Go</h3><p name="1b5b" id="1b5b" class="graf graf--p graf-after--h3">Go is very neat and its support for concurrency is powerful. So you should not think twice about your language choice when your task is to implement a concurrent image pixelizer. Although conventional threads are supported by Go, doing tasks concurrently is as simple as putting the <code class="markup--code markup--p-code">go</code> keyword at the beginning of a function:</p><pre name="86a1" id="86a1" class="graf graf--pre graf-after--p">go someFunction() {...}</pre><p name="1a3c" id="1a3c" class="graf graf--p graf-after--pre">This lightweight thread of execution is officially called a <strong class="markup--strong markup--p-strong">goroutine</strong>, and for a basic overview on goroutines, you can refer to the official <a href="https://tour.golang.org/concurrency/1" data-href="https://tour.golang.org/concurrency/1" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">go tour</a> (although it is not necessary for understanding this article). There have already been written dozens of other articles about goroutine <strong class="markup--strong markup--p-strong">channels</strong>, but the best article on the matter is definitely <a href="https://medium.com/rungo/anatomy-of-channels-in-go-concurrency-in-go-1ec336086adb" data-href="https://medium.com/rungo/anatomy-of-channels-in-go-concurrency-in-go-1ec336086adb" class="markup--anchor markup--p-anchor" target="_blank">Anatomy of Channels in Go</a>. I had also stumbled upon an <a href="https://medium.com/mop-developers/image-processing-in-go-part-2-using-goroutines-and-channels-to-parallelise-things-73bdc9a03db5" data-href="https://medium.com/mop-developers/image-processing-in-go-part-2-using-goroutines-and-channels-to-parallelise-things-73bdc9a03db5" class="markup--anchor markup--p-anchor" target="_blank">article</a> about image processing in Go, which illustrates the parallel execution of goroutines by creating an image collager.</p><p name="3a39" id="3a39" class="graf graf--p graf-after--p graf--trailing">But what do we want to program this time?</p></div></div></section><section name="bc9a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e331" id="e331" class="graf graf--h3 graf--leading">README.md</h3><p name="3d41" id="3d41" class="graf graf--p graf-after--h3">The program reads a .jpg file from the path, after which, from left to right, top to bottom, finds the average color for the (square size) x (square size) boxes. Then it sets the color of the whole square to that average color:</p><figure name="6878" id="6878" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qpoxqrTFdXyJ1mL_QODrGw.png" data-width="521" data-height="272" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*qpoxqrTFdXyJ1mL_QODrGw.png"><figcaption class="imageCaption">monalisa.jpg -&gt; result.jpg</figcaption></figure><p name="5458" id="5458" class="graf graf--p graf-after--figure">You can call it anything you want — pixelization, censorization, mosaic-maker. Two processing modes will be available for the user:</p><ul class="postList"><li name="70c0" id="70c0" class="graf graf--li graf-after--p">Single-threading [S]</li><li name="d2e3" id="d2e3" class="graf graf--li graf-after--li">Multi-threading [M]</li></ul><p name="52d2" id="52d2" class="graf graf--p graf-after--li">The application will take three arguments from the command line: <strong class="markup--strong markup--p-strong">file name</strong>, <strong class="markup--strong markup--p-strong">square size</strong>, and the <strong class="markup--strong markup--p-strong">processing mode</strong>. For example:</p><pre name="012b" id="012b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ go run main.go somefile.jpg 5 S</code></pre><p name="0f7a" id="0f7a" class="graf graf--p graf-after--pre">After the execution, the result will be stored in the <code class="markup--code markup--p-code">result.jpg</code> file.</p><p name="07eb" id="07eb" class="graf graf--p graf-after--p graf--trailing">If our goal is clear, let’s jump on to discuss the implementation. The full code you will find in the <a href="https://github.com/shahaliyev/conimg" data-href="https://github.com/shahaliyev/conimg" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github repository</a>.</p></div></div></section><section name="a51c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1998" id="1998" class="graf graf--h3 graf--leading">Planning out Concurrent Image Processor in Go</h3><p name="1184" id="1184" class="graf graf--p graf-after--h3">Let’s define in bullet points what we are supposed to do in order to achieve our goal:</p><ul class="postList"><li name="03b9" id="03b9" class="graf graf--li graf-after--p">Read an image file</li><li name="dba3" id="dba3" class="graf graf--li graf-after--li">Create a mask to draw our processed image on</li><li name="20b7" id="20b7" class="graf graf--li graf-after--li">Step over the original image in pre-defined square-sized steps</li><li name="2bc5" id="2bc5" class="graf graf--li graf-after--li">Find the average color of each square</li><li name="af7f" id="af7f" class="graf graf--li graf-after--li">Draw the resulting color to our mask</li><li name="c34b" id="c34b" class="graf graf--li graf-after--li">Save the final mask as our result</li></ul><p name="2fbc" id="2fbc" class="graf graf--p graf-after--li graf--trailing">But there will be lots of finesses along the way, as we are willing to implement our image processor concurrently.</p></div></div></section><section name="2c48" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e32d" id="e32d" class="graf graf--h3 graf--leading">Programming Concurrent Image Processor in Go</h3><p name="0b48" id="0b48" class="graf graf--p graf-after--h3 graf--trailing">The first steps are easy. Let’s create two functions for reading and saving a .jpg file. You can program it in another way to support any other format or formats.</p></div></div></section><section name="4489" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="5ca0" id="5ca0" class="graf graf--h4 graf--leading">Reading an image file</h4><pre name="a4e9" id="a4e9" class="graf graf--pre graf-after--h4">func openImage(imagePath string) image.Image {<br>    file, _ := os.Open(imagePath)<br>    defer file.Close() // cleanup<br>    img, _, _ := image.Decode(file)</pre><pre name="9a48" id="9a48" class="graf graf--pre graf-after--pre">    return img<br>}</pre><p name="e1bf" id="e1bf" class="graf graf--p graf-after--pre graf--trailing"><em class="markup--em markup--p-em">Note: I will not specify error checking which is very simple and can be found in the aforementioned repository.</em></p></div></div></section><section name="0810" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="9b08" id="9b08" class="graf graf--h4 graf--leading">Saving an image file</h4><pre name="1d2f" id="1d2f" class="graf graf--pre graf-after--h4">func saveImage(imagePath string, img image.Image) {<br>    ext := filepath.Ext(imagePath)<br>    dir := filepath.Dir(imagePath)<br>    newImagePath := fmt.Sprintf(&quot;%s/result%s&quot;, dir, ext)<br>    file, _ := os.Create(newImagePath)<br>    defer file.Close() <br>    jpeg.Encode(file, img, nil)<br>}</pre><p name="c985" id="c985" class="graf graf--p graf-after--pre graf--trailing">As the codes above are simple and self-explanatory, and as we are interested in the main logic, let’s skip the details here. However, if you are new to programming (not only to the Go programming language), simple googling should clarify the matters.</p></div></div></section><section name="c64e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="f933" id="f933" class="graf graf--h4 graf--leading">Iterating over an image</h4><p name="59f0" id="59f0" class="graf graf--p graf-after--h4">Our next step was to create a mask for the image to draw our result on. However, as we are going to define it in the main function, let’s, for now, assume that we already have a copy of the image called <code class="markup--code markup--p-code">res</code> .</p><p name="0786" id="0786" class="graf graf--p graf-after--p">Now we should write a code for our main logic to iterate over the whole image by square-sized steps.</p><pre name="6dd2" id="6dd2" class="graf graf--pre graf-after--p">for x := startX; x &lt; sizeX; x = x + squareSize {<br>    for y := startY; y &lt; sizeY; y = y + squareSize {<br>    // process the image  <br>  }<br>}</pre><p name="f195" id="f195" class="graf graf--p graf-after--pre">We can get rid of starting variables by specifying them as <code class="markup--code markup--p-code">0</code> , however, as we are going to use goroutines and give them different starting points by modifying the function, we will keep them.</p><p name="8c76" id="8c76" class="graf graf--p graf-after--p">Now we can write the logic for processing an image. We will have to create a temporary mask for finding the average color of each square in the image. For this, we are going to use Go’s image package, which is simple and nice. It is also powerful if your task is only consisting of manipulating rectangles and drawing simple shapes.</p><p name="badb" id="badb" class="graf graf--p graf-after--p">Let’s create a mask for each rectangle in the image, find the average of its colors, and then draw the averaged color on our result mask.</p><pre name="05ed" id="05ed" class="graf graf--pre graf-after--p">temp = image.NewRGBA(image.Rect(x,y, x+squareSize, y+squareSize))</pre><p name="37b2" id="37b2" class="graf graf--p graf-after--pre">The code above creates a rectangle by defining starting and ending points and then parses it into the RGBA color model.</p><pre name="8248" id="8248" class="graf graf--pre graf-after--p">color = averageColor(x, y, x+squareSize, y+squareSize, res)</pre><p name="6204" id="6204" class="graf graf--p graf-after--pre">This code, on the other hand, finds the average color for each square. We will soon define the logic for the <code class="markup--code markup--p-code">averageColor</code> function.</p><pre name="1c23" id="1c23" class="graf graf--pre graf-after--p">draw.Draw(res, temp.Bounds(), &amp;image.Uniform{color}, image.Point{x, y}, draw.Src)</pre><p name="4fa1" id="4fa1" class="graf graf--p graf-after--pre">Finally, we draw the averaged color into the resulting mask (which we will define in the main function). Let’s connect all the dots to get the whole picture.</p><pre name="1236" id="1236" class="graf graf--pre graf-after--p">func processImage(startX, startY, sizeX, sizeY, squareSize, goroutineIncrement int, res draw.Image) {<br>   var temp image.Image <br>   var color color.Color</pre><pre name="ffae" id="ffae" class="graf graf--pre graf-after--pre">   for x := startX; x &lt; sizeX; x = x + goroutineIncrement {<br>      for y := startY; y &lt; sizeY; y = y + squareSize {<br>         <em class="markup--em markup--pre-em">// creating a temporary mask for the square<br>         </em>temp = image.NewRGBA(image.Rect(x, y, x+squareSize, y+squareSize))<br>         <em class="markup--em markup--pre-em">// finding the average color for the square<br>         </em>color = averageColor(x, y, x+squareSize, y+squareSize, res)<br>         <em class="markup--em markup--pre-em">// setting the color for the square<br>         </em>draw.Draw(res, temp.Bounds(), &amp;image.Uniform{color}, image.Point{x, y}, draw.Src)<br>      }<br>   }<br>}</pre><p name="3627" id="3627" class="graf graf--p graf-after--pre graf--trailing">Note that we also step by squares by the<code class="markup--code markup--p-code">goroutineIncrement</code> on the x-axis which we are going to define later.</p></div></div></section><section name="1712" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="4592" id="4592" class="graf graf--h4 graf--leading">Finding the average color</h4><p name="6424" id="6424" class="graf graf--p graf-after--h4">The following logic is based on the <a href="https://jimsaunders.net/2015/05/22/manipulating-colors-in-go.html" data-href="https://jimsaunders.net/2015/05/22/manipulating-colors-in-go.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">article</a> by Jim Saunders. Although there is a <a href="https://sighack.com/post/averaging-rgb-colors-the-right-way" data-href="https://sighack.com/post/averaging-rgb-colors-the-right-way" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">more efficient way</a> of finding the average, a common-sense option is to iterate over a rectangle, put the red colors into the red bucket, the green colors into the green bucket, and the blue colors into the blue bucket (no need to calculate alpha). After which, it is enough to divide each RGB element by the number of pixels and return the color.</p><pre name="0563" id="0563" class="graf graf--pre graf-after--p">const convertRGB = 0x101<br>const alpha = 255<br><br>func averageColor(startX, startY, sizeX, sizeY int, img image.Image) color.Color {<br>   var redBucket, greenBucket, blueBucket uint32<br>   var red, green, blue uint32 <br>   var area uint32</pre><pre name="f902" id="f902" class="graf graf--pre graf-after--pre">   area = uint32((sizeX - startX) * (sizeY - startY))<br><br>   <em class="markup--em markup--pre-em">// separating rgba elements and finding each bucket&#39;s size<br>   </em>for x := startX; x &lt; sizeX; x++ {<br>      for y := startY; y &lt; sizeY; y++ {<br>         <em class="markup--em markup--pre-em">// no need to calculate alpha<br>         </em>red, green, blue, _ = img.At(x, y).RGBA()<br>         redBucket += red<br>         greenBucket += green<br>         blueBucket += blue<br>      }<br>   }<br><br>   <em class="markup--em markup--pre-em">// averaging each bucket<br>   </em>redBucket = redBucket / area<br>   greenBucket = greenBucket / area<br>   blueBucket = blueBucket / area<br><br>   <em class="markup--em markup--pre-em">// returning the color<br>   </em>return color.NRGBA{uint8(redBucket / convertRGB), uint8(greenBucket / convertRGB), uint8(blueBucket / convertRGB), alpha}<br>}</pre><p name="a10e" id="a10e" class="graf graf--p graf-after--pre graf--trailing">It’s simple, huh? Let’s finally define our main function, destination mask, and…goroutines.</p></div></div></section><section name="be1d" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6acc" id="6acc" class="graf graf--h3 graf--leading">The main goroutine</h3><p name="c996" id="c996" class="graf graf--p graf-after--h3">One peculiarity of Golang is that its main function is itself a goroutine — the main goroutine. This means that the non-main goroutines are going to execute concurrently with the main goroutine, and there is a chance for the main goroutine to complete its execution before other goroutines. Even though I knew it, still, I was unfamiliar with the usage of wait groups and it took me a while to figure out the correct implementation of goroutines (thanks to the help of stackoverflow).</p><p name="56dc" id="56dc" class="graf graf--p graf-after--p">Let’s declare our variables in the main function.</p><pre name="6ffa" id="6ffa" class="graf graf--pre graf-after--p">var wg sync.WaitGroup<br>var sizeX, sizeY int<br>var img image.Image<br>var res *image.RGBA<br>var goroutineCount int = 1<br>var goroutineIncrement int</pre><p name="e678" id="e678" class="graf graf--p graf-after--pre">We initialize <code class="markup--code markup--p-code">goroutineCount</code> to <code class="markup--code markup--p-code">1</code> as the default mode will be single-threaded.</p><p name="3345" id="3345" class="graf graf--p graf-after--p">Then we need to read from the command line and open the image from the given path. <code class="markup--code markup--p-code">readCommandLine</code> function is simple and doesn’t need explanation (again, you can find the full code in the Github repository).</p><pre name="004b" id="004b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">imagePath, squareSize, processingMode := readCommandLine()<br>img = openImage(imagePath)</code></pre><p name="5599" id="5599" class="graf graf--p graf-after--pre">Let’s get the image size to ease the later usage.</p><pre name="4ba8" id="4ba8" class="graf graf--pre graf-after--p">sizeX = img.Bounds().Size().X<br>sizeY = img.Bounds().Size().Y</pre><p name="318f" id="318f" class="graf graf--p graf-after--pre">Finally, we can define the destination mask. The logic of the code below is the same as in the image processing function when we draw the averaged square on a mask. Simply, the purpose of the code below is to copy the image into the mask.</p><pre name="bb16" id="bb16" class="graf graf--pre graf-after--p">res = image.NewRGBA(image.Rect(0, 0, sizeX, sizeY))<br>draw.Draw(res, res.Bounds(), img, image.Point{0, 0}, draw.Src)</pre><p name="fcf2" id="fcf2" class="graf graf--p graf-after--pre">Now let’s see how we are going to define the number of goroutines in the case of multi-threading. As we are going to process our image from top to bottom, we need to define the number of goroutines based on the image’s x-axis. That is, if the size of the image is 300 pixels and it is demanded to average 10 pixeled boxes, we are going to have 30 goroutines, one for processing each vertical line.</p><pre name="529f" id="529f" class="graf graf--pre graf-after--p">if processingMode == &quot;M&quot; {<br>   goroutineCount = int(math.Ceil(float64(sizeX) / float64(squareSize)))<br>}</pre><p name="3db5" id="3db5" class="graf graf--p graf-after--pre">After knowing our goroutine count, we can add them to the waiting group. The wait group simply takes into account the number of goroutines that the main goroutine needs to wait for.</p><pre name="e5a0" id="e5a0" class="graf graf--pre graf-after--p">wg.Add(goroutineCount)</pre><p name="838d" id="838d" class="graf graf--p graf-after--pre">In the end, we need to also define our <code class="markup--code markup--p-code">goroutineIncrement</code> variable to correctly “step” over the image.</p><pre name="5a76" id="5a76" class="graf graf--pre graf-after--p graf--trailing">goroutineIncrement = goroutineCount * squareSize</pre></div></div></section><section name="c8ba" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="951e" id="951e" class="graf graf--h3 graf--leading">Culmination</h3><p name="5d0c" id="5d0c" class="graf graf--p graf-after--h3">Finally, attention please, here comes the goroutine implementation. In a for loop, we defer all the goroutines, each starting at square size apart (<code class="markup--code markup--p-code">i*squareSize</code>).</p><pre name="3d19" id="3d19" class="graf graf--pre graf-after--p">for i := 0; i &lt; goroutineCount; i++ {<br>   go func(i int) {<br>      defer wg.Done()<br>      processImage(i*squareSize, 0, sizeX, sizeY, squareSize, goroutineIncrement, res)<br>   }<br>}(i)</pre><p name="8e11" id="8e11" class="graf graf--p graf-after--pre">We then save the image and make the main goroutine wait for it.</p><pre name="be97" id="be97" class="graf graf--pre graf-after--p">defer saveImage(imagePath, res)</pre><p name="e2f4" id="e2f4" class="graf graf--p graf-after--pre">Finally, we force the main goroutine to wait for other goroutines until everything else completes their execution.</p><pre name="ad93" id="ad93" class="graf graf--pre graf-after--p graf--trailing">wg.Wait()</pre></div></div></section><section name="ba06" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="30a4" id="30a4" class="graf graf--h3 graf--leading">Future Work</h3><p name="7e88" id="7e88" class="graf graf--p graf-after--h3 graf--trailing">For sure, the program is very simplistic and further optimizations are possible. In case there is a bug that I am not aware of, feel free to point it out or pull requests.</p></div></div></section><section name="f388" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8ff2" id="8ff2" class="graf graf--h3 graf--leading">Github</h3><p name="e4a0" id="e4a0" class="graf graf--p graf-after--h3 graf--trailing"><a href="https://github.com/shahaliyev/conimg" data-href="https://github.com/shahaliyev/conimg" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/shahaliyev/conimg</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@shahaliyev" class="p-author h-card">Ismayil Shahaliyev</a> on <a href="https://medium.com/p/71164ad660d2"><time class="dt-published" datetime="2020-12-15T11:04:57.339Z">December 15, 2020</time></a>.</p><p><a href="https://medium.com/@shahaliyev/concurrent-image-processing-in-go-pixelization-71164ad660d2" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 18, 2023.</p></footer></article></body></html>